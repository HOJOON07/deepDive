# Chapter1. 프로그래밍

### 1. 프로그래밍이란?
> __컴퓨터에게 실행을 요구하는 일종의 `커뮤니케이션`__
>
> (0과 1밖에 모르는 기계가 실행할 수 있을 정도로 __`정확하고 상세하게 요구사항을 설명`__ 하는 작업)

#### <프로그래밍에 있어 필요한 역량>
```
  1. 문제 해결 능력
  2. 컴퓨팅 사고(Computational Thinking)
```

### 2. 프로그래밍 언어
> 컴퓨팅 사고와 문제해결 능력을 바탕으로 정의된 문제 해결방안을 컴퓨터에게 전달하기 위해서는 프로그래밍 언어를 사용해야함
<img src="https://github.com/Elelero/deepDive/assets/91528640/875edca1-8fd5-4cba-bcf9-f5789a58dcf9" width="500" height="110"/>

```
  1. 사람이 이해할 수 있는 약속된 구문(문법)으로 구성된 "프로그래밍 언어" 를 사용하여 프로그램을 작성한 후,
          ↓
  2. "번역기(컴파일러 & 인터프리터)"를 사용하여,
          ↓
  3. 컴퓨터가 이해할 수 있는 "기계어"로 변환
```
- 프로그래밍 언어는 `구문(syntax)`과 `의미(semantics)`의 조합으로 표현됨
- 프로그래밍을 함에 앞서 __올바른 구문과 의미로 프로그래밍 언어를 작성__ 해야 요구사항 실현(문제 해결)을 진행할 수 있음
<br/> <br/> 
> ### ∴ 프로그래밍 = 요구사항의 집합을 분석해서 적절한 자료구조와 함수의 집합으로 변환한 후, 그 흐름을 제어하는 것
> ( 프로그래밍의 목적은 __`문제해결`__ 이다!! )

<br/> <br/> <br/> 
# Chapter2. 자바스크립트란?

### 1. 자바스크립트의 탄생
#### [ 1995년 ] 
> __넥스케이프 커뮤니케이션즈__ 에서 웹페이지의 보조적인 기능을 수행하기 위해 브라우저에서 동작하는 경량 프로그래밍 언어를
>
> 도입하기 위해 __`자바스크립트`__(作 브렌던 아이크)를 개발

#### [ 1996년 - 3월 ] 
>__넷스케이프 내비게이터2__(=넥스케이프 커뮤니케이션즈의 웹 브라우저) 에 자바스크립트 탑재됨
>
> (이때, 자바스크립트는 __`모카(Mocha)`__ 로 명명됨)

#### [ 1996년 - 9월 ] 
> 모카였던 자바스크립트 이름이 __`라이브스크립트(LiveScript)`__ 로 바뀜 

#### [ 1996년 - 12월 ] 
> 최종적으로, __`자바스크립트(JavaScript)`__ 라는 이름으로 명명됨 
<img src="https://github.com/Elelero/deepDive/assets/91528640/2179acba-ce94-4ea6-b692-765cf8c97152" width="600" height="150"/>

### 2. 자바스크립트의 표준화
> 경쟁으로 인해 정상적인 웹페이지 개발이 어려워진 문제를 해결하기 위해 표준화 진행
<img src="https://github.com/Elelero/deepDive/assets/91528640/508b4a22-0772-42af-bb9b-c474059e671f" width="800" height="250"/>


- __크로스 브라우징 이슈__ = 브라우저에 따라 웹페이지가 정상적으로 동작하지 않는 문제

#### [ ECMAScript 버전별 특징 ]
|**버전**|출시연도|특징|
|:---|:---:|:---|
|ES1|1997|초판|
|ES2|1998|ISO/IEC 16262 국제 표준과 동일한 규격을 적용|
|ES3|1999|정규 표현식, try ... catch|
|ES5|2009|HTML5와 함께 출현한 표준안.</br> JSON, strict mode, 접근자 프로퍼티, 프로퍼티 어트리뷰트 제어, 향상된 배열 조작 기능</br> (forEach, map, filter, reduce, some, every)|
|ES6(ECMAScript 2015)|2015|let/const, 클래스, 화살표 함수, 탬플릿 리터럴, 디스트럭처링 할당, 스프레드 문법, rest 파라미터, 심벌, 프로미스, Map/Set, 이터러블, for ... of, 제너레이터, Proxy, 모듈 import/export|
|ES7(ECMAScript 2016)|2016|지수(**) 연산자, Array.prototype.includes, String.prototype.includes|
|ES8(ECMAScript 2017)|2017|async/await, Object 정적 메서드(Object.values, Object.entries, Object.getOwnPropertyDescriptors|
|ES9(ECMAScript 2018)|2018|Object rest/spread 프로퍼티, Promise.prototype.finally, async generator, for await ... of|
|ES10(ECMAScript 2019)|2019|Object.fromEntries, Array.prototype.flat, Array.prototype.flatMap, optional catch binding|
|ES11(ECMAScript 2020)|2020|String.prototype.matchAll, BigInt, globalThis, Promise.allSettled, null 병합 연산자, 옵셔널 체이닝 연산자, for ... in enumeration order|

### 3. 자바스크립트 성장의 역사
#### [ `Ajax` (1999년) ]
- 자바스크립트를 이용해 서버와 브라우저가 __비동기(asyncrhonous) 방식으로 데이터를 교환할 수 있는 통신 기능인 `AJAX`(Asynchronous JavaScript and XML)__ 가 __XMLHttpRequest__ 라는 이름으로 등장
- AJAX 덕분에 웹페이지에서 변경할 필요가 없는 부분은 다시 렌더링하지 않고, 서버로부터 필요한 데이터만 전송받아 변경해야하는 부분만 한정적으로 렌더링하는 방식 가능해짐
- 2005년의 구글 맵스가 자바스크립트와 Ajax 기반으로 개발되어 좋은 성능을 냄으로서 자바스크립트의 가능성 확인하는 계기가 됨
#### [ `jQuery` (2006년) ]
- 번거롭고 논란이 있던 __DOM(Document Object Model)을 더욱 쉽게 제어__ 할 수 있게 됨
- 또한, __크로스 브라우징 이슈도 어느정도 해결__ 해줌
#### [ `자바스크립트 엔진` (2008년) ]
- 구글의 __V8 자바스크립트 엔진__ 웹 애플리케이션을 더욱 빠르게 동작시켜줄 수 있는 성능을 보여줌
- V8 자바스크립트 엔진의 등장으로 자바스크립트는 데스크톱 애플리케이션과 유사한 __사용자 경험(UX; User Experience)__ 을 제공할 수 있는 웹 애플리케이션 프로그래밍 언어로 정착하게 됨
- 위 엔진으로 촉발된 자바스크립트의 발전으로 과거 웹 서버에서 수행되던 로직들이 대거 클라이언트(브라우저)로 이동하였음
  </br>
  => `웹 애플리케이션 개발에서 프론트엔드 영역이 주목받는 계기로 작용함!`
#### [ `Node.js` (2009년) ]
- __라이언 달__ 이 발표함
- 구글 V8 자바스크립트 엔진으로 빌드된 __자바스크립트 런타임 환경(runtime environment)__
- 브라우저 이외의 환경에서도 자바스크립트를 동작할 수 있도록 자바스크립트 엔진을 브라우저에서 독립시킨 자바스크립트 실행환경
- 서버 사이드 애플리케이션 개발에 주로 사용
- 모듈, 파일 시스템, HTTP 등의 __빌트인(built-in; 내장) API__ 를 제공함
- __비동기 I/O__ 를 지원함
- __단일 스레드(single thread) 이벤트 루프__ 기반으로 동작함으로써 요청처리 성능이 좋음
  </br>
  ∴ 데이터를 실시간으로 처리하기 위해 I/O가 빈번하게 발생하는 SPA(Single Page Application)에 적합
  </br>
  &nbsp; (But, CPU 사용률이 높은 애플리케이션에서는 권장x)
 <br/> <br/> 
> ### 자바스크립트는 "크로스 플랫폼"을 위한 가장 중요한 언어로 주목받고 있음!
> ( 크로스 플랫폼 = 컴퓨터 프로그램, 운영 체제, 컴퓨터 언어, 프로그래밍 언어, 컴퓨터 소프트웨어 등이 여러 종류의 컴퓨터 플랫폼에서 동작할 수 있다는 의미 )
#### [ `SPA 프레임워크` ]
- 개발 규모와 복잡도가 상승함과 동시에 많은 패턴과 라이브러리가 출현함
- 그 덕분에 개발에 큰 도움을 주었지만 변경에 유연하면서 확장하기 쉬운 애플리케이션 아키텍처의 구축을 어렵게 했음
  </br>
  => ∴ 필연적으로 프레임워크가 등장하게 되었음!
- __CBD(Component Based Development) 방법론__ 을 기반으로 하는 __SPA(Single Page Application)__ 대중화 되면서,
  </br>
  `Angular`, `React`, `Vue.js`, `Svelte` 등의 다양한 SPA 프레임워크/라이브러리 등장 및 사용多 
### 4. 자바스크립트와 ECMAScript
> EXMAScript = 자바의 표준사양 __EXMA-262__ 칭함 
> </br> 프로그래밍 언어의 값, 타입, 객체와 프로퍼티, 함수, 표준 빌트인 객체(Standard built-in object) 등 핵심문법을 규정함
- 자바스크립트 = 프로그래밍 언어의 기본뼈대(__ECMASciprt__) + 브라우저 별도 지원하는 __클라이언트 사이드 Web API__(DOM, BOM, Canvas, XMLHttpRequest, fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web Worker 등)
<img src="https://github.com/Elelero/deepDive/assets/91528640/161fac58-7d98-4e95-8206-226635825e66" width="170" height="150"/>


### 5. 자바스크립트의 특징
> 웹 브라우저에서 동작하는 유일한 프로그래밍 언어

```
  - 기본문법은 C, 자바와 유사
  - 셀프(Self)에서는 프로토타입 기반 상속 차용
  - 스키마(Scheme)에서는 일급함수 개념 차용
```
- 개발자가 별도의 컴파일 작업을 수행하지 않는 __인터프리터 언어__ 임
  </br>
  -> 인터프리터와 컴파일러의 장점을 결합하여 상대적으로 처리속도가 느린 인터프리터의 단점 해결
  </br>
  &nbsp; ( 인터프리터는 소스코드를 즉시 실행 + 컴파일러는 빠르게 동작하는 머신코드를 생성/최적화 )

#### <참고> 컴파일러 언어 vs. 인터프리터 언어
|**컴파일러 언어**|인터프리터 언어|
|:---|:---|
|코드가 실행되기 전 단계인 컴파일 타임에 소스코드 전체를 한번에 머신코드로 변환한 후 실행함|코드가 실행되는 단계인 런타임에 문 단위로 한 줄씩 중간코드인 바이트코드로 변환한 후 함|
|실행 파일 생성o|실행 파일 생성x|
|컴파일 단계와 실행단계가 분리o|인터프리트 단계와 실행 단계가 분리x|
|컴파일은 단 한번 수행|인터프리트 과정이 반복수행|
|실행속도 빠름|실행속도 느림|

- 자바스크립트는 런타임에 컴파일 되며 실행파일이 생성되지 않고 인터프리터의 도움 없이 실행할 수 없기에 컴파일러 언어라고 할 음
- 자바스크립트는 `명령형(imperative)`, `함수형(functional)`, `프로토타입 기반(prototype-based) 객체지향 프로그래밍`을 지원하는 __멀티 패러다임 프로그래밍 언어__ 임
- 자바스크립트는 클래스 기반 객체지향 언어보다 효율적이면서 강력한 __프로토타입 기반의 객체지향 언어__ 임

<br/> <br/> <br/> 
# Chapter3. 자바스크립트 개발환경과 실행방법

### 1. 자바스크립트 실행환경
- 모든 브라우저와 Node.js는 자바스크립트를 해석하고 실행할 수 있는 __자바스크립트 엔진을 내장__ 하고 있음
  </br> ∴ 브라우저에서 동작하는 코드는 Node.js 환경에서도 동일하게 동작함
- But, 브라우저와 Node.js 용도가 다름!!
  - __브라우저__: HTML, CSS, 자바스크립트를 실행해 웹페이지를 브라우저 화면에 렌더링하는 것이 주된 목적
  - __Node.js__: 브라우저 외부에서 자바스크립트 실행환경을 제공하는 것이 주된 목적
    </br>
    ```
      (ex1.) DOM API(파싱된 HTML 요소를 선택하거나 조작하는 기능의 집합)
          - 브라우저에서는 기본적으로 제공
          - Node.js 제공x ( ∵ 브라우저 외부 환경에서 HTML 요소를 파싱해서 객체화한 DOM을 직접 다룰 필요없기 때문 )

      (ex2.) 파일 시스템(파일 생성/수정)
          - 브라우저에서는 지원x
            => FileReader 객체(Web API)를 사용해 사용자가 지정한 파일을 읽어 들이는 것은 가능
          - Node.js에서는 기본적으로공
    ```
<img src="https://github.com/Elelero/deepDive/assets/91528640/0294fd7e-3bbd-47cb-882e-2a5bb6fcd46f" width="400" height="300"/>

### 2. 웹 브라우저
#### [ `개발자 도구(DevTools)` ]
|**패널**|설명|
|:---|:---|
|__Elements__|로딩된 웹페이지의 DOM과 CSS를 편집해서 렌더링된 뷰를 확인해 볼 수 있음. </br> 단, 편집한 내용이 저장되지는 않음. </br> 웹페이지가 의도된 대로 렌더링되지 않았다면 이 패널을 확인해 유용한 힌트를 얻을 수 있음|
|__Console__|로딩된 웹페이지의 에러를 확인하거나 자바스크립트 소스코드에 작성한 console.log 메서드의 실행결과를 확인할 수 있음. </br> 콘솔은 코드를 직접 입력해 그 결과를 확인할 수 있는 __REPL(Read Eval Print Loop; 입력 수행 출력 반복)__ 환경으로 사용할 음|
|__Sources__|로딩된 웹페이지의 자바스크립트 코드를 디버깅할 수 있음|
|__Network__|로딩된 웹페이지에 관련된 네트워크 요청(request) 정보와 성능을 확인할 수 있음|
|__Application__|웹 스토리지, 세션, 쿠키를 확인하고 관리할 수 있음|

<br/> <br/> <br/> 
# Chapter4. 변수

### 1. 변수란 무엇인가? 왜 필요한가?
> __변수(variable) = 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 or 그 메모리 공간을 식별하기 위해 붙인 이름__
- 컴퓨터는 CPU를 사용해 연산하고, 메모리를 사용해 데이터를 기억함
  ```
  > "메모리(memory)" = 데이터를 저장할 수 있는 메모리 셀(memory cell)의 집합체
    - 메모리 셀 하나의 크기 = 1Byte (8Bit)
    - 컴퓨터는 메모리 셀의 크기(1 바이트) 단위로 데이터를 저장(write) & 읽음(read)
    - 각 셀은 고유의 메모리 주소를 갖음
    - 메모리 주소는 메모리 공간의 위치를 나타냄
    - 메모리에 저장되는 모든 값은 `2진수`로 저장됨
   ```
  <img src="https://github.com/Elelero/deepDive/assets/91528640/2f0f78d3-3b9e-4649-a3cc-41ec80e53b0d" width="400" height="300"/>
 
- 변수는 __값의 위치를 가리키는 상징적인 이름__
- 변수는 컴파일러/인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행됨
> ### ∴ `변수`를 이용해 개발자가 직접 메모리 주소를 통해 값을 저장하고 참조할 필요없이 `안전하게 값에 접근`할 수 있음! 

#### `변수이름(명)` = 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름
#### `할당(assignment; 대입,저장)` = 변수에 값을 저장하는 것
#### `참조(reference)` = 변수에 저장된 값을 읽어 들이는 것

- 변수이름을 사용해 참조를 요청하면 자바스크립트 엔진은 변수명과 매핑된 메모리 주소를 통해 메모리 공간에 접근해서 저장된 값을 반환함

### 2. 식별자(identifier)
> __어떤 값을 구별해서 식별할 수 있는 고유한 이름__
> ( = 변수 이름)
- 식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별해서 식별해낼 수 있어야함!
  </br> (식별자는 어떤 값이 저장되어 있는 메모리 주소를 기억(저장)해야함)
- __식별자는 (값이 아니라) 메모리 주소를 기억__ 하고 있음

- ∴ 식별자 => 메모리 주소에 붙인 이름 
- 식별자의 대표적인 예로는 `변수`, `함수`, `클래스` 등의 `이름`에 사용됨
  </br> (메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름 모두 식별자라 칭함)

### 3. 변수 선언(variable declaration)
> __= 변수를 생성하는 것__
> 값을 저장하기 위한 메모리 __공간을 확보(allocate)__ 하고, 변수 이름과 확보된 메모리 공간의 __주소를 연결(name binding)__ 해서 값을 저장할 수 있게 준비하는 것
- 변수를 사용하려면 __반.드.시 선언이 필수!__
- 변수를 선언할 때, __`var`__, __`let`__, __`const`__ 키워드 사용함
```
  <참고> "var" 키워드 단점
  - 블록 레벨 스코프(block-level scope) 지원x
  - 함수 레벨 스코프(function-levl scope) 지원o
  ⇒ 의도치 않게 전역 변수가 선언된다는 부작용 야기
  ⇒ 이를 보완하고자 생긴 것이 "let", "const" 키워드!
```
```
  <참고> 키워드(keyword)
  - 자바스크립트 코드를 해석하고 실행하는 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어
  - 자바스크립트 엔진은 키워드를 만나면 자신이 수행해야할 약속된 동작을 수행함 
```
- 변수를 선언하고 값을 할당하지 않으면, 자바스크립트 엔진에 의해 암묵적으로 __`undefined`__ 라는 값이 할당되어 초기화됨

- #### <자바스크립트 엔진의 변수선언 단계(2단계)>
  1. __선언단계__ : 변수 이름을 등록해서 자바스크립트 엔진에 의해 변수의 존재를 알림
  2. __초기화단계__ : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화함

### 4. 변수 선언의 실행시점과 변수 호이스팅
> __변수 선언은 런타임(소스코드가 한 줄씩 순차적으로 실행되는 시점)이 아닌 그 이전 단계에서 먼저 실행됨__
```javascript
  console.log(score); // undefined  → 두번째로 실행

  var score;                        → 첫번째로 실행
```
- 자바스크립트 엔진은 __변수 선언__ 이 소스코드의 어디에 있든 상관없이 __다른 코드보다 먼저 실행함__
  </br> ∴ 변수 선언 소스코드가 어디에 위치하는지 상관없음!

> ### 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅(variable hoisting)이라 칭함
- 변수 선언뿐만 아니라 var, let, const, function, function*, class 키워드를 사용해서 선언하는 모든 식별자 호이스팅됨!)
  </br> (∵ 모든 선언문은 런타임 이전 단계에서 먼저 실행되기 때문!)

### 5. 값의 할당
> 변수에 값을 할당할 때, 할당 연산자 __`=`__ 사용함
```javascript
  var score;      // 변수 선언
  score = 80;     // 값의 할당

  var score = 80; // 변수 선언과 값의 할당 
```
- 하나의 문으로 단축표현해도 자바스크립트 엔진은 변수 선언과 값의 할당을 2개로 나누어 각각 실행함
- 변수 선언과 값의 할당 실행시점 다름
  - __변수 선언__ : 런타임 이전에 먼저 실행됨
  - __값의 할당__ : 런타임에 실행됨
```javascript
  console.log(score);  // undefined
  var score;           // 1. 변수 선언
  score = 80;          // 2. 값의 할당

  console.log(score);  // 80 
```
- 참고로, 변수에 값을 할당할 때는 이전 값 undefined가 저장되어 있는 공간을 지우지 않고, 새로운 메모리 공간을 확보하여 할당값을 저장함!
  <img src="https://github.com/Elelero/deepDive/assets/91528640/25ca3b33-28f9-4287-8a18-c1809d41d01d" width="450" height="200"/>

### 6. 값의 재할당
> __재할당__ = 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것
```javascript
  var score = 80;  // 변수 선언과 값의 할당
  score = 90;      // 값의 재할당
```
- 값을 재할당할 수 있음 => __변수__
- 값을 재할당할 수 없음 => __상수__

 <img src="https://github.com/Elelero/deepDive/assets/91528640/3230d34d-2bfb-4c0f-a724-faab60d16c21" width="700" height="200"/>

- 참고로, 더 이상 쓰이지 않는 undefined와 80은 __가비지 컬렉터__ 에 의해 메모리에서 자동해제 됨!
  - __가비지 컬렉터(garbage collector)__
    - 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능
    - 자바스크립트는 가비지 콜렉터를 내장하고 있는 매니지드 언어 ⇒ 메모리 누수(memory leak) 방지함

### 7. 식별자 네이밍 규칙
- 식별자는 특수문잘를 제외한 문자, 숫자, 언더스코어(_), 달러 기호($)를 포함할 수 있음
- 숫자로 시작하는 것 허용x
- 예약어는 식별자로 사용x
  </br> <참고> __예약어__
  |await|break|case|catch|class|const|
  |:---:|:---:|:---:|:---:|:---:|:---:|
  |continue|debugger|default|delete|do|else|
  |enum|export|extends|false|finally|for|
  |function|if|implements*|import|in|instanceof|
  |interface*|let*|new|null|package*|private*|
  |protected*|public*|return|super|static*|switch|
  |this|throw|true|try|typeof|var|
  |void|while|with|yield|||

- __네이밍 컨벤션(naming convention)__ = 하나 이상의 영어 단어로 구성된 식별자를 만들 때 가독성 좋게 단어를 한눈에 구분하기 위해 규정한 명명 규칙
  ``` javascript
    <네이밍 컨벤션의 4가지 유형>
    // 1.  카멜 케이스(camelCase)
    var firstName;

    // 2. 스네이크 케이스(snake_case)
    var first_name;

    // 3. 파스칼 케이스(PascalCase)
    var FirstName;

    // 4. 헝가리언 케이스(typeHungarianCase)
    var strFristName;
    var $elem = document.getElementById('myId);     // DOM 노드
    var observable$ = fromEvent(document, 'click')  // RxJS 옵저러블
  ```
- 변수, 함수의 이름 ⇒ 카멜 케이스 사용
- 생성자 함수, 클래스 이름 ⇒ 파스칼 케이스 사용

<br/> <br/> <br/> 
# Chapter5. 표현식과 문

### 1. 값(Value)
> __식(표현식; Expression)이 `평가(Evaluate)`되어 생성된 결과__

```
  평가 = 식을 해석해서 값을 생성하거나 참조하는5것
```

- 모든 값은 데이터 타입을 가짐
- 메모리에 2진수(비트; bit) 나열로 저장됨

#### 변수
> __`하나의 값` 을 저장하기 위해 확보한 메모리 공간자체__
>     or    __메모리 공간을 식별하기 위해 붙인 이름__

``` 
  ∴ 변수에 할당되는 것 = 값 
```

### 2. 리터럴(Literal)
> __사람이 이해할 수 있는 문자__
>     or    __약속된 기호를 사용해 `값을 생성`하는 표기법(notation)__

- 자바스크립트 엔진은 __런타임(runtime; 코드가 실행되는 시점)__ 에 리터럴을 평가해 값을 생성함

|**리터럴**|예시|비고|
|:---:|:---:|:---:|
|정수 리터럴|100||
|부동소수점 리터럴|10.5||
|2진수 리터럴|0b01000001|0b로 시작|
|8진수 리터럴|0o101|ES6에서 도입, 0o로 시작|
|16진수 리터럴|0x41|ES6에서 도입, 0x로 시작|
|문자열 리터럴|'hello', "world"||
|불리언 리터럴|true, false||
|null 리터럴|null||
|undefined 리터럴|undefined||
|객체 리터럴|{ name:  'Lee', address: 'Seoul' }||
|배열 리터럴|[ 1, 2, 3 ]||
|함수 리터럴|function() {}||
|정규 표현식 리터럴|/[A-Z]+/g||

### 3. 표현식(Expression)
> __값으로 평가될 수 있는 문(statement)__

> __즉, 표현식이 평가되면 새로운 값을 생성하거나 기존값을 참조함__

- __값으로 평가될 수 있는 문은 모두 표현식!!__
 
### 4. 문(Statement)
> __프로그램을 구성하는 기본 단위이자 최소 실행 단위__
- __토큰(Token)__ = 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소

<img src="https://github.com/Elelero/deepDive/assets/91528640/f01eca5e-2bce-47b0-ab5a-52011efd9783" width="=300" height="200"/>

- 문 = 명령문 = 컴퓨터에 내리는 명령
- <종류>
  - 선언문
  - 할당문
  - 조건문
  - 반복문

### 5. 세미콜론과 세미콜론 자동 삽입 기능
> __세미콜론(;)__ 은 문의 __종료__ 를 의미
- 중괄호로 묶인 코드블록({...}) 뒤에는 세미콜론 붙이지 않음
  </br> ( ∵ 코드블록은 언제나 문의 종료를 의미하는 __자체 종결성(self closing)을 갖고 있기 때문! )
- 자바스크립트 엔진이 문의 끝으로 예측되는 지점에 세미콜론을 자동으로 붙여주는 __세미콜론 자동 삽입 기능(ASI; Automatic Semicolon Insertion)__ 이 암묵적으로 수행됨

### 6. 표현식인 문 vs 표현식이 아닌 문
> 구별방법: __변수에 할당해보는 것__

<br/> <br/> <br/> 
# Chapter6. 데이터 타입

|**구분**|데이터 타입|설명|
|:---:|:---|:---|
|원시 타입|숫자(number) 타입|숫자. 정수와 실수 구분없이 하나의 숫자 타입만 존재|
|         |문자열(string) 타입|문자열|
|         |불리언(boolean) 타입|true, false|
|         |undefined 타입|var 키워드로 선언된 변수에 암묵적으로 할당되는 값|
|         |null 타입|값이 없다는 것을 의도적으로 명시할 때 사용하는 값|
|         |심벌(symbol) 타입|ES6에서 추가된 7번째 타입|
|객체 타입||객체, 함수, 배열 등|

### 1. 숫자타입
> 자바스크립트는 하나의 숫자타입만 존재함! ⇒ __배정밀도 64비트 부동소수점 형식__
- 모든 수를 __실수__ 로 처리함
  </br> (정수만 표현하기 위한 데이터타입 존재x)
- 정수로 표시되는 수끼리 나누더라도 실수가 나올 수 있음!

- 숫자 타입의 3가지 특별한 값 표현
  - __`Infinity`__ : 양의 무한대
  - __`-Infinity`__ : 음의 무한대
  - __`NaN`__ : 산술 연산 불가 (Not-a-Number)

- 자바스크립트는 대소문자 구별(case-sensitive)함
  </br> <참고> NaN과 NAN, Nan, nan은 엄연히 다른 것! ( NAN, Nan, nan ⇒ 값이 아닌 식별자로 해석!)

### 2. 문자열타입
> __0개 이상의 16비트 유니코드 문자(UTF-16)의 집합__
- 작은따옴표(''), 큰따옴표(""), 백틱(``) 으로 텍스트 감쌈
  </br> (자바스크립트에서 가장 일반적인 표기법은 '작은따옴표'를 사용하는 것!)
```
  <문자열을 따옴표로 감싸는 이유>
  - 키워드나 식별자와 같은 토큰과 구별하기 위해서!!!
```
- 자바스크립트 문자열은 원시타입으로 __변경 불가능한 값(immutable value)__ 임
  </br>(문자열이 생성되면 그 문자열을 변경할 수 없다는 것을 의미)
  
### 3. 템플릿 리터럴
> ES6부터 도입된 새로운 문자열 표기법
>
> __멀티라인 문자열__, __표현식 삽입__, __태그드 템플릿__ 등 편리한 문자열 처리 기능 제공
- 런타임에 일반 문자열로 변환되어 처리됨!
- 템플릿 리터럴은 일반적으로 `백틱(``)`을 사용해 표현함

#### [ `멀티라인 문자열` ]
- 일반 문자열내에서는 줄바꿈(개행)이 허용되지 않아 __이스케이프 시퀀스__ 를 사용해야함!
  |**이스케이프 시퀀스**|의미|
  |:---:|:---|:---|
  |\0|Null|
  |\b|백스페이스|
  |\n|개행(다음행으로 이동)|
  |\r|개행(커서를 처음으로 이동)|
  |\'|작은따옴표|
  |\"|큰따옴표|
  |\\|백슬래시|
  ```javascript
      var template = '<ul>\n\t<li><a href="#">Home</a></li>\n</ul>';
      console.log(template);

      // 결과
      // <ul>
      //   <li><a href="#">Home</a></li>
      // <ul>
  ```

- __템플릿 리터럴__ 내에서는 __이스케이프 시퀀스를 사용하지 않고__ 줄바꿈이 __허용__ 되며, 모든 공백도 있는 그대로 적용됨!
  ```javascript
      var template = `<ul>
        <li><a href="#">Home</a></li>
      </ul>`;
      console.log(template);

      // 결과
      // <ul>
      //   <li><a href="#">Home</a></li>
      // <ul>
  ```

  #### [ `표현식 삽입` ]
- __템플릿 리터럴__ 내에서는 표현식 삽입을 통해 __깐단히 문자열 삽입__ 가능!
- 표현식을 삽입하기 위해서는 __${ }__ 으로 표현식을 감싸야함!
- 표현식의 평과결과가 문자열이 아니더라도 문자열 타입으로 강제 변환되어 삽입됨
  ```javascript
    var first = 'Ung-mo';
    var last = 'Lee';
    console.log(`My name is ${first} ${last}.`); // My name is Ung-mo Lee.

    console.log(`1 + 2 = ${1 + 2}`); // 1 + 2 = 3
  ```

### 4. 불리언 타입
- 논리적 참(true), 논리적 거짓(false) 값 2개만 존재

### 5. undefined 타입
- undefined 타입의 값은 __`undefined`__ 가 유일함
- var 키워드로 선언한 변수는 암묵적으로 undefined로 초기화함
  </br> (개발자가 의도적으로 할당하기 위한 값이 아니라 자바스크립트 엔진이 변수를 초기화 할 때 사용하는 값!!)
 - 변수에 값이 없다는 것을 명시적으로 표시하고 싶을 때는 __`null`__ 을 할당해줌

```
  <참고> 선언과 정의
  - 변수는 "선언한다" 라고 표현!
  - 함수는 "정의한다" 라고 표현!
```

### 6. null 타입
- null 타입의 값은 __`null`__ 가 유일함
- null != Null, NULL
- 변수에 값이 없다는 것을 의도적으로 명시 __(의도적 부재)__ 할 때 사용함
- 변수에 null을 할당한다는 의미는 `이전에 참조했던 값을 더이상 참조하지 않겠다는 의미`
  </br> (이전에 할당된 값을 제거함으로서 가비지 콜렉션 가동)
- `함수가 유효한 값을 반환할 수 없는 경우`에도 명시적으로 null을 반환함
  
### 7. 심벌(symbol) 타입
- 외부에 노출x + 절대 중복되지 않는 __유일무이__ 값
- 이름이 충돌할 위험이 없는 객체의 유일한 __프로퍼티 키__ 를 만들기 위해 사용
- __Symbol__ 함수를 호출하여 심벌 생성함
  
### 8. 객체 타입
- 자바스크립트는 객체 기반의 언어이며, __자바스크립트를 이루고 있는 거의 모든 것이 객체__ 라는 것만 일단 알아두기!
  
### 9. 데이터 타입의 필요성
> __1. 데이터 타입에 의한 메모리 공간의 확보와 참조__
> __2. 데이터 타입에 의한 값의 해석__
```
  - 값을 저장할 때 확보해야 하는 "메모리 공간의 크기"를 결정하기 위해
  - 값을 참조할 때 한 번에 읽어 들여야 할 "메모리 공간의 크기"를 결정하기 위해
  - 메모리에서 읽어 들인 "2진수를 어떻게 해석"할지 결정하기 위해
```

### 10. 동적 타이핑
#### [ `동적 타입 언어 vs 정적 타입 언어` ]
- __정적 타입 언어__ : 변수 선언할 때, 변수에 할당할 수 있는 데이터 타입을 __사전에__ 선언해야함(명시적 타입 선언)
  - 컴파일 시점에 __타입 체크(선언한 데이터 타입에 맞는 값 할당 여부 검사)__ 를 수행함
  - (ex) C, C++, 자바, 코틀린, 고, 하스켈, 러스트, 스칼라 ...
    
- __동적 타입 언어__ : 변수 선언할 때, 데이터 타입을 선언하지 않음
  - 키워드(var, let, const) 키워드를 사용해 변수를 선언함
  - 미리 선언한 데이터 타입의 값만 할당하지 않아도 된다는 자유도가 있음
  - 유연성은 높지만 신뢰성이 떨어짐짐
  - (ex) 자바스크립트, 파이썬, PHP, 루비, 리스프, 펄 ...

 
  > __자바스크립트 변수는 선언이 아닌 `할당`에 의해 타입이 결정(타입 추론) 됨__
  > </br> 또한 __재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있음(동적 타이핑)__

<br/> <br/> <br/> 
# Chapter7. 연산자(operator)
> 연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만듬
- 표현식 = 피연산자(명사) + 연산자(동사)

### 1. 산술 연산자
> 수학적 계산을 수행해 새로운 숫자값 생성
- 이항 산술 연산자, 단항 산술 연산자로 구분 가능

#### [ `이항 산술 연산자` ]
> 2개의 피연산자를 산술 연산하여 숫자 값 만듬
- 피연산자의 값을 변경하는 부수 효과 없음
- 종류: __+, -, *, /, %__

#### [ `단항 산술 연산자` ]
> 1개의 피연산자를 산술 연산하여 숫자 값 만듬
- 증감(++/--)연산자는 피연산자의 값을 변경하는 부수 효과 있음
- 종류: __++, --, +, -__
  
#### [ `문자열 연결 연산자` ]
> __연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작함__
```javascript
  // true는 1로 타입 변환됨
  1 + true = 2;

  // null은 0으로 타입 변환됨
  1 + null = 1;

  // undefined는 숫자로 타입변환되지 않음
  +undefined;     // NaN
  1 + undefined;  // NaN
```
- __암묵적 타입 변환__ or __타입 강제 변환__ 이 일어남

### 2. 할당 연산자
> 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당
- 좌항의 변수값을 할당하므로 변수값이 변하는 부수효과 있음
- 종류: __=, +=, -=, *=, /=, %=__
- __할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가됨__

### 3. 비교 연산자
> 좌항/우항의 피연산자를 비교하여 불리언 값으로 결과 반환함
- 주로, if문이나 for문과 같은 제어문의 조건식에서 많이 쓰임
  
#### [ `동등/일치 비교 연산자` ]
> 좌항과 우항의 피연산자가 같은 값으로 평가되는지 비교함
- 동등 비교 연산자 vs 일치 비교 연산자
  - __동등 비교 연산자__ : 비교에 앞서 __먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교함__
    - 종류: __==, !=__
  - __일치 비교 연산자__ : __피연사자의 타입이 같은 경우에 한아여 값이 같을 경우에 true를 반환함__
    - 종류: __===, !==__
- NaN은 자신과 일치하지 않는 유일한 값!!! ⇒ NaN인지 조사하려면 빌트인 함수 __Number.isNaN__ 사용해야함
- __Object.is()__ 메소드를 이용해 일치 비교 연산 가능!

#### [ `대소 관계 비교 연산자` ]
- 종류: __>, >=, <, <=__

### 4. 삼항 조건 연산자
> __조건식 ? 조건식 true일 경우 반환할 값 : 조건식 false일 경우 반환할 값__
> </br> __값으로 평가할 수 있는 표현식인 문__
- 자바스크립트의 유일한 삼항 연산자이며, 부수효과x

### 5. 논리 연산자
> 우항/좌항의 피연산자를 논리 연산
- 참고로, 부정논리 연산자의 경우 우항의 피연산자를 논리 연산함
- 종류: __||(논리합), &&(논리곱), !(부정)__
- 드 모르간의 법칙으로 복잡한 표현식을 더욱 가독성 좋게 변환할 수 있음
  - !(x || y) === (!x && !y)

### 6. 쉼표 연산자
> 왼쪽 피연산자부터 차례대로 평가하고 마지막 피연산자의 평가가 끝나면, 마지막 피연산자의 평가 결과 반환
```javascript
  var x, y, z;
  x = 1, y = 2, z = 3;  // 3
```

### 7. 그룹 연산자
> 소괄호(' __()__ ')로 감싼 표현식을 먼저 평가
- 우선순위 가장 높음

### 8. typeof 연산자
> 피연산자의 데이터 타입을 문자열로 반환함
```javascript
  typeof ''            // string
  typeof 1             // number 
  typeof NaN           // number
  typeof true          // boolean
  typeof undefined     // undefined
  typeof Symbol()      // symbol
  typeof null          // object -> 자바스크립트 첫번째 버전의 버그
  typeof []            // object
  typeof {}            // object
  typeof new Date()    // object
  typeof /test/gi      // object
  typeof function() {} // function
```
- null 타입인지 확인할 때는 일치 연산자(===)를 사용해야함!

### 9. 지수 연산자
> 좌항의 피연산자를 밑(base)으로, 우항의 피연산자를 지수(exponent)로 거듭 제곱하여 숫자값 반환
```javascript
  // ES7 이후 도입된 지수 연산자
  2 ** 2;     // 4
  2 ** 0;     // 1

  // 원래 지수 연산자
  Math.pow(2, 2);  // 4

  // 음수를 밑으로 사용하려면 소괄호로 묶어야함
  (-5) ** 2;  // 25
```

### 10. 그 외 연산자
|**연산자**|개요|
|:---:|:---|
|?.|옵셔널 체이닝 연산자|
|??|null 병합 연산자|
|delete|프로퍼티 삭제|
|new|생성자 함수를 호출할 때 사용하여 인스턴스 생성|
|instance of|좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별|
|in|프로퍼티 존재 확인|

<br/> <br/> <br/> 
# Chapter8. 제어문
> 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용
- 참고, forEach, map, filter, reduce와 같은 고차함수를 이용해 제어문 사용을 억제하여 복잡성 해결

### 1. 블록문
> 0개 이상의 문을 중괄호로 묶은 것
- 자체 종결성 갖고 있음 -> 세미콜론 안붙임
  
### 2. 조건문
> 주어진 조건식의 평가 결과에 따라 코드 블록(블록문)의 실행을 결정함
> </br> (불리언 값으로 평가될 수 있는 표현식)
- 종류: __if...else문__, __switch문__

### 3. 반복문
> 조건식의 평가 결과가 참인 경우 코드블록을 실행함
- 종류: __for문__, __while문__, __do...while문__
```
  <반복문 대체할 수 있는 다양한 기능>
  - forEach 메소드: 배열 순회할 때 사용
  - for ... in 문 : 객체의 프로퍼티를 열거할 때 사용
  - for ... of 문 : 이터러블(ES6 도입) 순회할 때 사용
```
- for문은 반복횟수가 확실할 때 사용하고, while문은 반복횟수가 불명확할 때 사용함
  
### 4. break 문
> 코드 블록(레이블문, 반복문, switch문)을 탈출

### 5. continue 문
> 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킴
- break문과 달리 반복문 탈출x

<br/> <br/> <br/> 
# Chapter9. 타입 변환과 단축 평가

### 1. 타입 변환
> - 개발자가 의도적으로 값의 타입을 변환하는 것 = __명시적 타입 변환__ / __타입 캐스팅__
>
> - 개발자가 의도와 상관없이 값의 타입을 변환하는 것 = __암묵적 타입 변환__ / __타입 강제 변환__

### 2. 암묵적 타입 변환
```javascript
  // 문자열로 타입 변환
  '10' + 2    // '102'

  // 숫자 타입 변환
  5 * '10'    // 50

  // 불리언 타입 변환
  !0          // true
```

### 3. 명시적 타입 변환
#### [ `문자열 타입으로 변환` ]
```javascript
  1. String 생성자 함수를 new 연산자없이 호출하는 방법
  // 숫자타입 -> 문자열 타입
  String(1)    // '1'
  String(NaN)  // 'NaN'
  // 불리언타입 -> 문자열 타입
  String(true)  // 'true'

  2. Object.prototype.toString 메소드를 사용하는 방법
  // 숫자 타입 -> 문자열 타입
  (1).toString();      // '1'
  // 불리언타입 -> 문자열 타입
  (true).toString();  // 'true'
  
  3. 문자열 연결 연산자를 이용하는 방법
  // 숫자 타입 -> 문자열 타입
  1 + '';      // '1'
  // 불리언타입 -> 문자열 타입
  true + '';   // 'true'
```
#### [ `숫자 타입으로 변환` ]
```javascript
  1. Number 생성자 함수를 new 연산자없이 호출하는 방법
  // 문자열타입 -> 숫자 타입
  Number('1')    // 1
  // 불리언타입 -> 숫자 타입
  Number(true)  // true

  2. parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능)
  // 문자열타입 -> 숫자 타입
  parseInt('0');   // 0
  parseFloat('10.53');   // 10.53
  
  3. + 단항 산술 연산자 이용하는 방법
  // 문자열타입 -> 숫자 타입
  +'0';      // 0
  // 불리언타입 -> 숫자 타입
  +true;     // 1

  4. * 산술 연산자 이용하는 방법
   // 문자열타입 -> 숫자 타입
  '0' * 1;      // 0
  // 불리언타입 -> 숫자 타입
  true * 1;     // 1
```
#### [ `불리언 타입으로 변환` ]
- Boolean 생성자 함수를 new 연산자 없이 호출하는 방법
- ! 부정 논리 연산자 두 번 사용하는 방법
  
### 4. 단축 평가 ★★★
> 논리 연산자를 이용하여 단축 평가할 수 있음
```javascript
  true || anything        // true
  false || anything       // anything
  true && anything        // anything
  false && anything       // false
```
#### 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티 참조할 때
```javascript
  var elem = null;
  var value = elem && elem.value;  // null
```

#### 함수 매개변수에 기본값을 설정할 때
```javascript
  function getStringLength(str) {
    str = str || '';
    return str.length;
  }

  getStringLength();      // 0
  getStringLength('hi');  // 2
```

### 5. 옵셔널 체이닝 연산자 ★★★
> 좌항의 피연산자가 null 또는 undefined인 경우에 undefined 반환


### 6. null 병합 연산자 ★★★
