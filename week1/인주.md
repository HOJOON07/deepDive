# 04장 변수

## 4.1 변수란 무엇인가? 왜 필요한가?

`변수`: 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름

## 4.2 식별자

- 어떤 값을 구별해서 식별할 수 있는 고유한 이름
- 값이 아닌 메모리 주소를 기억
- 메모리 주소를 통해 메모리 공간에 저장된 값에 접근
- 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름 전부를 칭함 (변수, 함수, 클래스 등)
- 선언을 통해 자바스크립트 엔진에 식별자의 존재를 알림

## 4.3 변수 선언

`변수 선언`: 값을 저장하기 위한 **메모리 공간을 확보**하고 **변수 이름과 확보된 메모리 공간의 주소를 연결**해서 값을 저장할 수 있게 준비하는 것

- 변수를 사용하려면 반드시 선언이 필요
- 변수 선언 시 `var`, `let`, `const` 키워드 사용

```javascript
var score; // == undefined
```

var 키워드는 변수에 값을 할당하지 않으면 자바스크립트 엔진에 의해 `undefined`라는 값이 암묵적으로 할당되어 초기화

#### 실행 컨텍스트

> - 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역
>- 변수 이름을 비롯한 모든 식별자는 실행 컨텍스트에 등록
>- 자바스크립트 엔진은 실행 컨텐스트를 통해 식별자와 스코프를 관리

## 4.4 변수 선언의 실행 시점과 변수 호이스팅

`변수 호이스팅(Hosting)` : 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징

```javascript
console.log(score); // undefined

var score; // 변수 선언문
```

자바스크립트는 **인터프리터**에 의해 한 줄씩 순차적으로 실행되므로 위에 코드는 score 변수가 선언되기 전에 참조했기 때문에 ReferenceError가 발생할 것처럼 보이나 에러가 발생하지
않고 `undefind가 출력`된다.

변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임(Runtime)이 아니라 그 이전 단계에서 먼저 실행되기 때문이다.

## 4.5 값의 할당

```javascript
var score;  // 변수 선언
score = 80; // 값의 할당
```

```javascript
var score = 80; // 변수 선언과 값의 할당
```

변수 선언과 값의 할당은 위와 같이 하나의 문으로 단축 표현할 수 있다.  
하지만 자바스크립트 엔진은 변수 선언과 값의 할당을 하나의 문으로 단축 표현해도 값의 할당을 2개의 문으로 나누어 각각 실행한다.

`변수 선언`: 소스코드가 순차적으로 실행되는 **런타임 이전에 먼저 실행**  
`값의 할당`: 소스코드가 순차적으로 실행되는 **런타임에 실행**

## 4.6 값의 재할당

변수에 값을 재할당하면 처음 값이 저장된 메모리 공간을 지우고 그 메모리 공간에 재할당 값을 새롭게 저장하는 것이 아니라
새로운 메모리 공간에 저장한다.  
처음 값이 저장된 불필요한 메모리 공간은 가비지 콜렉터에 의해 메모리에서 자동 해제된다.  
단, 메모리에서 언제 해제될지는 예측할 수 없다.

`가비지 콜렉터`: 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능

- 언매니지드 언어
    - 제어를 개발자가 주도할 수 있음
    - 최적의 성능을 확보 가능
    - 치명적 오류를 생산할 가능성 존재
    - ex) C언어
- 매니지드 언어
    - 메모리 할당 및 해제와 같은 메모리 관리 기능을 언어 차원에서 담당
    - 개발자의 직접적인 메모리 제어 허용 X
    - 개발자의 역량 의존 적어 어느 정도 일정한 생산성을 확보 가능
    - 성능 면에서 어느 정도의 손실 감수
    - ex) 자바스크립트

## 4.7 식별자 네이밍 규칙

- 식별자는 특수문자를 제외한 **문자, 숫자, 언더스코어(_), 달러 기호($)** 를 포함 할 수 있다.
- 식별자는 숫자로 시작할 수 없다.
- **예약어**는 식별자로 사용할 수 없다.
- 유니코드 문자(한글, 일본어 등) 허용 (권장 X)
- 쉼표(,)로 구분해 하나의 문에서 여러 개를 한번에 선언할 수 있다. (가독성 X)
- 자바스크립트는 **대소문자 구별**
- 변수의 존재 목적을 쉽게 이해할 수 있도록 의미를 명확히 표현해야 한다.

### 네이밍 컨벤션(Naming Convention)

```javascript
// 카멜 케이스(camelCase)
// 일반적으로 변수나 함수에 사용
var fistMan;

// 스네이크 케이스(snake_case)
// 생성자 함수. 클래스명
var first_man;

// 파스칼 케이스(PascalCase)
var FirstMan;

// 헝가리언 케이스(typeHungarianCase)
// 변수 및 함수의 인자 이름 앞에 데이터 타입을 명시하는 코딩 규칙
var strFirstMan;
var $elem = document.getElementById("myId");
var observable$ = fromEvent(document, "click");
```

- - -

# 05장 표현식과 문

## 5.1 값

`값`: 식(표현식)이 평가되어 생성된 결과

```javascript
// 10 + 20은 평가되어 숫자 값 30을 생성
10 + 20; // 30

// 변수에는 10 + 20이 평가되어 생성된 숫자 값 30이 할당
var sum = 10 + 20; //30
```

## 5.2 리터럴

`리터럴`: 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법

자바스크립트 엔진은 코드가 실행되는 시점인 런타임에 리터럴을 평가해 값을 생성한다.

```javascript
// 숫자 리터럴 3
3
```

## 5.3 표현식

`표현식`: 값으로 평가될 수 있는 문으로, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.

값으로 평가될 수 있는 문은 모두 표현식이다.

```javascript
//리터럴 표현식
10
'Hello'

//식별자 표현식
sum
person.name
arr[1]

// 연산자 표현식
10 + 20
sum = 10
sum !== 20

// 함수/메서드 호출 표현식
square()
person.getName()
```

## 5.4 문

`문(statement)`: 프로그램을 구성하는 기본 단위이자 최소 실행 단위  
`토큰(token)`: 문법적인 의미를 가지며, 문법적으로 더 이상 나눈 수 없는 코드의 기본 요소를 의미

문은 여러 토큰으로 구성된다.

```javascript
//변수 선언문
var x;

//변수 할당문
x = 5;

//함수 선언문
function foo() {
}

//조건문
if (x > 1) {
  console.log(x);
}

//반복문
for (var i = 0; i < 2; i++) {
  console.log(i);
}
```

## 5.5 세미콜론과 세미콜론 자동 삽입 기능

- 자바스크립트 엔진은 세미콜론으로 문이 종료한 위치를 파악하고 순차적으로 하나씩 문을 실행 한다.
- 단, 0개 이상의 문을 중괄호로 묶은 코드 블록({ ... }) 뒤에는 세미콜론을 붙이지 않는다.
- 코드 블록은 언제나 문의 종료를 의미하는 자체 종결성을 갖기 떄문이다.
- 자바스크립트 엔진은 세미콜론 자동 삽입 기능(ASI)이 암묵적으로 수행되므로 문의 끝에 붙이는 세미롤론은 생략 가능하다.
- 세미콜론 자동 삽입 기능의 동작과 개발자의 예측이 일치하지 않는 경우 발생 가능

```javascript
function foo() {
  return
  {
  }
  // ASI의 동작 결과 => return; {};
  // 개발자의 예측 => return {};
}

console.log(foo()); // undefined
```

## 5.6 표현식인 문과 표현식이 아닌 문

표현식인 문은 값으로 평가될 수 있는 문, 표현식이 아닌 문은 값으로 평가될 수 없는 문을 말한다.

둘을 구분하는 가장 간단한 방법은 변수에 할당해 보는 것이다

```javascript
// 표현식이 아닌 문은 값처럼 사용할 수 없다.
var foo =
var x; // SyntaxError: Unexpected token var

// 변수 선언문은 표현식이 아닌 문이다.
var x;

// 할당문은 그 자체가 표현식이지만 완전한 문이기도 하다. 즉, 할당문은 표현식인 문이다.
x = 100;
```

- - -

# 06장 데이터 타입

자바스크립트(ES6)는 7개의 데이터 타입을 제공

- 원시타입
    - 숫자 타입: 숫자, 정수와 실수 구분 없이 하나의 숫자 타입만 존재
    - 문자열 타입: 문자열
    - 불리언 타입: 논리적 참(true)과 거짓(false)
    - undefined 타입: var 키워드로 선언된 변수에 암묵적으로 할당되는 값
    - null 타입: 값이 없다는 것을 의도적으로 명시할 때 사용하는 값
    - 심벌 타입: ES6에 추가된 7번째 타입
- 객체 타입: 객체, 함수, 배열 등

## 6.1 숫자 타입

자바스크립트는 정수,실수 구분 없이 하나의 숫자 타입만 존재한다.

ECMAScript 사양에 따르면 숫자 타입의 값은 배정밀도 64비트 부동소수점 형식을 따른다.

즉, 모든 수를 실수로 처리한다.

```javascript
// 숫자 타입은 모두 실수 처리
console.log(1 === 1.0); // true
```

숫자 타입은 세 가진 특별한 값도 표현할 수 있다.

- Infinity: 양의 무한대
- -Infinity: 음의 무한대
- NaN: 산술 연산 불가(not a number)

```javascript
console.log(10 / 0);          // Infinity
console.log(10 / -0);         // -Infinity
console.log(1 * 'String');  // NaN
```

## 6.2 문자열 타입

문자열 타입은 텍스트 데이터를 표현한다. 0개 이상의 16비트 유니코드 문자(UTF-16)의 집합으로 전 세계 대부분의 문자를 표현할 수 있다.

문자열은 '', "", `` 으로 표현할 수 있다.

## 6.3 템플릿 리터럴

ES6부터 도입되어 멀티라인 문자열, 표현식 삽입, 태그드 템플릿 등 다양한 문자열 처리 기능을 제공합니다.

템플릿 리터럴은 백틱(``)을 사용해 표현한다.

### 멀티라인 문자열

```javascript
var str = `hello
world
!`;
```

### 표현식 삽입

```javascript
var first = '길동';
var last = '홍';

// ES5: 문자열 연결
console.log('my name is ' + first + ' ' + last + '.');

// ES6: 표현식 삽입
console.log(`my name is ${first}${last}.`);
```

## 6.4 불리언 타입

불리언 타입의 값은 논리적 참, 거짓을 나타내는 true와 false 뿐이다.

```javascript
// 값을 불리언 타입으로 명시적으로 표현하는 방법
var a = 10;
var b = 0;

console.log(!!a);   // true
console.log(!!b);   // false
```

## 6.5 undefined 타입

undefined 타입의 값은 undefined가 유일하다.

var 키워드로 선언한 변수는 암묵적으로 undefined로 초기화된다.

## 6.6 null 타입

null 타입의 값은 null이 유일하다.

자바스크립트는 대소문자를 구별하므로 Null, NULL 등과 다르다.

변수에 값이 없다는 것을 의도적으로 명시하거나 함수가 유효한 값을 반환할 수 없는 경우에 사용한다.

## 6.7 심벌 타입

심벌은 ES6에서 추가된 7번째 타입으로, 변경 불가능한 원시 타입의 값이다.

심벌 값은 다른 값과 중복되지 않는 유일무이한 값으로, 주로 이름이 충동할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다.

```javascript
// 심벌 값 생성
let key = Symbol('key');
console.log(typeof key); //symbol

let obj = {};

obj[key] = 'value';
console.log(obj[key]); //value
```

## 6.8 객체 타입

자바스크립트는 객체 기반의 언어이며, 자바스크립트를 이루고 있는 거의 모든 것이 객체이다.

11장에서 ~

## 6.9 데이터 타입의 필요성

- 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
- 값을 참조할 때 한 번에 읽어들여야 할 메모르 공간의 크기를 결정하기 위해
- 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해

## 6.10 동적 타이핑

`동적 타이핑`: 변수가 선언이 아닌 할당에 의해 타입이 결정되고, 변수의 타입은 언제든지 동적으로 변할 수 있는 특징

동적 타입 언어는 융연성은 높지만 신뢰성은 떨어진다.

동적 언어에서 변수 사용 시 주의할 사항

- 변수는 꼭 필요한 경우에 한해 제한적으로 사용
- 변수의 유효 범위는 최대한 좁게 만들어 변수의 부작용을 억제
- 전역 변수는 최대한 사용 X
- 변수보다는 상수를 사용해 값의 변경을 억제
- 변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍

- - -

# 07장 연산자

연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행하여 하나의 값을 만든다.

## 7.1 산술 연산자

산술 연산이 불가능한 경우 NaN을 반환한다.

### 이항 산술 연산자

### 단항 상술 연산자

- ++: 증가
- --: 감소
- +: 어떠한 효과도 없다. 음수를 양수로 반전하지도 않는다.
- -: 양수를 음수로, 음수를 양수로 반전한 값을 반환한다.

### 문자열 연결 연산자

'+' 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.

```javascript
'1' + 2;    // '12'
1 + '2';    // '12'

// true는 1, false와 null은 0으로 타입 변환
1 + true;   // 2

// undefined는 숫자로 타입 변환되지 않는다.
1 + undefined는; // NaN
```

## 7.2 할당 연산자

할당 연산자는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다.

```javascript
var str = 'my name is ';
str += 'Lee';
console.log(str);   // 'my name is Lee'
```

## 7.3 비교 연산자

- == : 동등 비교(x와 y의 값이 같음)
- === : 일치 비교(x와 y의 값과 타입이 같음)
- != : 부동등 비교(x와 y의 값이 다름)
- !== : 불일치 비교(x와 y의 값고 타입이 다름)

```javascript
// NaN은 자신과 일치하지 않는 유일한 값이다.
NaN === NaN // false 

// 양의 0과 음의0은 일치
0 === -0    // true
```

## 7.4 삼항 조건 연산자

삼항 조건 연산자는 조건식의 평가 결과에 따라 반환할 값을 결정한다.

{조건식} ? {조건식이 true일 때 반환할 값} : {조건식이 false일 때 반환할 값}

```javascript
var result = x % 2 ? '홀수' : '짝수'; // 결과: 짝수
```

## 7.5 논리 연산자

논리 연산자는 우항과 좌항의 피연산자를 논리 연산한다.

- || : 논리합(OR)
- && : 논리곱(AND)
- ! : 부정(NOT)

```javascript
// 암묵적 타입 변환
!0;         // true
!'Hello';   //false

// 단축 평가
'Cat' && 'Dog'; // 'Dog' 
```

## 7.6 쉼표 연산자

쉼표(,) 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 별과를 반환한다.

```javascript
var x, y, z;

x = 1, y = 2, z = 3; // 3
```

## 7.7 그룹 연산자

소괄호('()')로 피연산자를 감싸는 그룹 연산자는 자신의 피연산자인 표현식을 가장 먼저 평가한다.   
따라서 그룹 연산자를 사용하면 연산자의 우선순위를 조절할 수 있다.  
그룹 연산자는 연산자 우선순위가 가장 높다.

```javascript
10 * 2 + 3; // 23

10 * (2 + 3); // 50
```

## 7.8 typeof 연산자

typeof 연산자는 피연산자의 데이터 타입을 문자열로 반환한다.

선언되지 않은 식별자를 typeof 연산자로 연산하면 undefined를 반환한다.

반환되는 7가지 데이터 타입

- string
- number
- boolean
- undefined
- symbol
- object
- function

## 7.9 지수 연산자

ES7에서 도입된 지수 연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 값을 반환한다.

ES7 전까지는 Math.pow 메서드를 사용했다.

```javascript
2 ** 2;         // 4
Math.pow(2, 2)  // 4
```

## 7.10 그 외의 연산자

- ?. : 옵셔널 체이닝 연산자
- ?? : null 병합 연산자
- delete : 프로퍼티 삭제
- new : 생성자 함수를 호출할 때 사용하여 인스턴스를 생성
- instanceof : 좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별
- in : 프로퍼티 존재 확인

## 7.11 연산자의 부수 효과

대부분의 연산자는 다른 코드에 영향을 주지 않는다.

부수 효과가 있는 연산자는 할당 연산자(=), 증가/감소 연산자(++/--), delete 연산자다.

## 7.12 연산자 우선순위

1. ()
2. new(매개변수 존재), ., [ \](프로퍼티 접근), ()(함수 호출), ?.(옵셔널 체이닝 연산자)
3. new(매개변수 미존재)
4. x++, x--
5. !x, +x, -x, ++x, --x, typeof, delete
6. **
7. *,/,%
8. +,-
9. <,<=,>,>=,in,instanceof
10. ==, !=, ===, !==
11. ??(null 병합 연산자)
12. &&
13. ||
14. ? ... : ...
15. 할당 연산자(=, +,, -=, ...)
16. ,

## 7.13 연산자 결합 순서

- 좌항 -> 우항
    - +, -, /, % , 비교연산자, 논리 연산자, . , [], ??, ? . ,in, instanceof
- 우항 -> 좌항
    - ++, --, 할당 연산자, !x, +x, -x, ++x, --x, typeof ,delete, ? ... : ..., **

- - -

# 08장 제어문

`제어문`: 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용

## 8.1 블록문

`블록문`: 0개 이상의 문을 중괄호로 묶은 것 (= 코드 블록)

블록문은 언제나 문의 종료를 의미하는 자체 종결성을 갖기 때문에 블록문의 끝에는 세미콜론을 붙이지 않는다.

```javascript
// 블록문
{
  var foo = 10;
}

//제어문
var x = 1;
if (x < 10) {
  x++;
}

// 함수 선언문
function sum(a, b) {
  return a + b;
}
```

## 8.2 조건문

`조건문`: 주어진 조건식의 평가 결과에 따라 코드 블록(블록문)의 실행을 결정

코드 블록 내의 문이 하나뿐이라면 중괄호를 생략할 수 있다.

### if ... else 문

- - -

```javascript
// if... else 문
if (조건식) {
  // 조건식이 참이면 실행
} else {
  // 조건식이 거짓이면 실행
}
```

```javascript
//if... else if 문
if (조건식1) {
  // 조건식 1이 참이면 실행
} else if (조건식2) {
  // 조건식 1은 거짓이고
  // 조건식 2는 참이면 실행
} else {
  // 조건식 1, 2가 거짓이면 실행
}
```

if ... else 문은 삼항 조건 연산자로 바꿔 쓸 수 있다.

```javascript
var x = 2;

// 0은 false로 취급된다.
var result = x % 2 ? '홀수' : '짝수'; // 결과: 짝수
```

### switch 문

- - -

```javascript
switch (표현식) {
  case 표현식1:
    // switch 문의 표현식과 표현식1이 일치하면 실행될 문;
    break;
  case 표현식2:
    // switch 문의 표현식과 표현식2가 일치하면 실행될 문;
    break;
  default:
  // switch 문의 표현식과 일치하는 case 문이 없을 때 실행될 문;  
}
```

case 문에 해당하는 문의 마지막에 break 문을 사용하지 않으면 switch 문을 빠져나가지 못하고 다음 case 문을 실행한다.  
default 문은 switch 문의 맨 마지막에 위치하므로 별도의 break 문이 필요 없다.

## 8.3 반복문

`반복문`: 조건식의 평가 결과가 참인 경우 코드 블록을 실행 (조건식이 거짓일 때까지 반복)

### for 문

- - -
for 문은 조건식이 거짓으로 평가될 때까지 코드 블록을 반복 실행한다.

```javascript
for (변수 선언문
또는
할당문;
조건식;
증감식
)
조건식이
참인
경우
반복
실행될
문;
```

for 문의 변수 선언문, 조건식, 증감식은 모두 옵션이므로 반드시 사용할 필요는 없다.  
단, 어떤 식도 선언하지 않으면 무한루프가 된다.

```javascript
// 문한루프
for (; ;) { ...
}
```

### while 문

- - -
while 문은 주어진 조건식의 평가 결과가 참이면 코드 블록을 계속해서 반복 실행한다.  
for 문은 반복 횟수가 명확할 때 주로 사용하고 while 문은 반복 횟수가 불명확할 때 주로 사용한다.  
조건식의 평가 결과는 불리언 값으로 강제 변환하여 논리적 참, 거짓을 구별한다.

```javascript
var count = 0;

while (count < 3) {
  console.log(count);
  count++;
}

//무한 루프
while (true) { ....
} 
```

### do ... while 문

- - -
do ... while 문은 코드 블록을 먼저 실행하고 조건식을 평가한다.  
즉, 코드 블록은 무조건 한 번 이상 실행된다.

```javascript
var count = 0;

do {
  console.log(count);
  count++;
} while (count < 3);
```

### break 문

- - -
레이블 문, 반복문 또는 switch 문의 코드 블록을 탈출한다.  
해당 문 외에 break 문을 사용하면 SyntaxError(문법 에러)가 발생한다.

`레이블 문`: 식별자가 붙은 문

```javascript
// foo라는 레이블 식별자가 붙은 레이블 문
foo : console.log('foo');

// foo라는 식별자가 붙은 레이블 블록문
foo: {
  console.log(1);
  break foo; // foo 레이블 블록문을 탈출
  console.log(2);
}
```

### continue 문

- - -
continue 문은 반복문의 코드 블록 실행을 현 시점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다.  
break 문처럼 반복문을 탈출하지는 않는다.

```javascript
//특정 문자의 개수를 세는 코드
var string = 'Hello World';
var search = 'l';
var count = 0;

for (let i = 0; i < string.length; i++) {
  // 'l'이 아니면 현 지점에서 실행을 중단하고 반복문의 증감식으로 이동한다.
  if (string[i] !== search) continue;
  count++; // continue 문이 실행되면 이 문은 실행되지 않는다.
}

console.log(count); // 3
```

- - -

# 09장 타입 변환과 단축 평가

## 9.1 타입변환이란?

`명시적 타입 변환` / `타입 캐스팅 `: 개발자가 의도적으로 값의 타입을 변환하는 것

```javascript
var x = 10;

// 명시적 타입 변환
var str = x.toString();
console.log(typeof str, str); // string 10
```

`암묵적 타입 변환` / `타입 강제 변환`: 자바스크립트 엔진에 의해 암묵적으로 타입이 변환되는 것

```javascript
var x = 10;

// 암묵적 타입 변환
var str = x + '';
console.log(typeof str, str); // string 10
```

## 9.2 암묵적 타입 변환

### 문자열 타입으로 변환

`+`연산자는 피연산자 중 하나 이상이 문자열이면 문자열 연결 연산자로 동작한다.

```javascript
// 숫자 타입
1 + '2'         // '12'
0 + '';         // '0'
-0 + '';        // '0'
1 + '';         // '1'
-1 + '';        // '-1'
NaN + '';       // 'NaN'
Infinity + '';  // 'Infinity'
-Infinity + ''; // '-Infinity'

// 불리언 타입
true + '';      // 'true'
false + '';     // 'false'

// null 타입
null + '';      // 'null'

//undefined 타입
undefined + ''; // 'undefined'

// 심벌 타입
(Symbol()) + ''; // TypeError: cannot convert a Symbol value to a string

// 객체 타입
({}) + '';      // '[object Object]'
Math + '';      // '[object Math]'
[] + '';        // ''
[10, 20] + '';  // '10, 20'
(function () {
}) + ''; // 'function(){}'
Array + '';     // 'function Array() { [native code] }'
```

### 숫자 타입으로 변환

```javascript
1 - '1'     // 0
1 * '10'    // 10
1 / 'one'   // NaN

'1' > 0     // true    

// 문자열 타입
+ '';        // 0
+'0';       // 0
+'1';       // 1
+'string';  // NaN

// 불리언 타입
+true;      // 1
+false;     // 0

// null 타입
+null;      // 0

// undefined 타입
+undefined; // NaN

// 심벌 타입
+Symbol(); // TypeError: Cannot convert a Symbol value to a number

// 객체 타입
+{};        // NaN
+[];        // 0
+[10, 20];  // NaN
+(function () {
}); // NaN
```

### 불리언 타입으로 변환

자바스크립트 엔진은 조건식의 평가 결과를 불리언 타입으로 암묵적 타입 변환 한다.

이떄 자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy 값(거짓으로 평가되는 값)으로 구분한다.

```javascript
if ('') console.log('1');
if (true) console.log('2');
if (0) console.log('3');
if ('str') console.log('4');
if (null) console.log('5');

// 2 4
```

## 9.3 명시적 타입 변환

### 문자열 타입으로 변환

문자열 타입이 아닌 값을 문자열 타입으로 변환하는 방법

- String 생성자 함수를 new 연산자 없이 호출하는 방법
- Object.prototype.toString 메서드를 사용하는 방법
- 문자열 연결 연산자를 이용하는 방법

```javascript
String(1);          // '1'
String(NaN);        // 'NaN'
String(Infinity);   // 'Infinity'

(1).toString();     // '1'
(NaN).toString();   // 'NaN'

1 + '';             // '1'
NaN + '';           // 'NaN'
```

### 숫자 타입으로 변환

숫자 타입이 아닌 값을 숫자 타입으로 변환하는 방법

- Number 생성자 함수를 new 연산자 없이 호출하는 방법
- parseInt, parseFloat 함수를 사용하는 방법 (문자열만 가능)
- `+` 단항 산술 연산자를 이용하는 방법
- `*` 산술 연산자를 이용하는 방법

```javascript
Number('0');        // 0
Number(true);       // 1
parseInt('0');      // 0
parseFloat('10.53');// 10.56
+'0';               // 0
'0' * 1;            // 0
'-1' * 1;           // 1
```

### 불리언 타입으로 변환

불리언 타입이 아닌 값을 불리언 타입으로 변환하는 방법

- Boolean 생성자 함수를 new 연산자 없이 호출하는 방법
- `!` 부정 논리 연산자를 두 번 사용하는 방법

```javascript
Boolean('x');       // true
Boolean('');        // false
Boolean('false');   // true
Boolean(0);         // false
Boolean(1);         // true
Boolean(NaN);       // false
Boolean(null);      // false
Boolean(undefined); // false

!!'x';              // true
!!'';               // false
!!0;                // false
!!NaN               // false
!!null;             // false
!!undefined;        // false
```

## 9.4 단축 평가

### 논리 연산자를 사용한 단축 평가

`논리곱(&&)`: 두 개의 피연산자가 모두 true로 평가될 때 true를 반환한다.

`논리합(||)`: 두 개의 피연산자 중 하나만 true로 평가되어도 true를 반환한다.

```javascript
true || 'anything'  // true
false || 'anything' // 'anything'
true && 'anything'  // 'anything'
false && 'anything'  // false
```

### 옵셔널 체이닝 연산자

옵셔널 체이닝 연산자 `?.`는 좌항의 피연산자가 null 또는 undefined인 경우 undefined를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.

```javascript
var elem = null;

var value = elem?.value;
console.log(value);  //undefined
```

### null 병합 연산자

ES11에서 도압된 null 병합 연산자 `??`는 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환하고 그렇지 않으면 좌항의 피연산자를 반환한다. 이 연산자는 변수에 기본값을 설정할
때 유용하다.

```javascript
var foo = null ?? 'default string';
console.log(foo);  // "default string"
```

