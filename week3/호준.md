## 내부 슬롯과 내부 메서드

> [[]]로 감싼 것들

- [[...내부 슬롯, 내부 메서드]]
- 내부 슬롯과 내부 메서드는 원칙적으로는 개발자가 접근 불가능하다

```
[[Prototype]] => __proto__
```

## 데이터 프로퍼티와 접근자 프로퍼티

```
const person = {
  name : "Lee"
}
console.log(Object.getOwnPropertyDescriptor(person, 'name'))
```

## get ,set (접근자 함수)

```
const person = {
  firstName : 'hojoon'
  lastName : "Kim"

  get fullname () {
  return {`${this.firstName}+${this.lastName}`}
  };

  set fullName (name) {
  [this.firstName,this.lastName] = name.split(")
  };
}

persone.fullname = "Hojoon fullName"
console.log(person)
// {firstName : Hojoon, lastName : fullName}

console.log(person.fullname)
//Hojoon fullName
```

### 프로토타입

- 어떤 객체의 상위 객체의 역할을 한다.
- 프로토타입은 하위(자식)에게 상속한다.
- 프로퍼티 또는 메서드가 없다면 프로토타입 체인을 따라 프로토타입의 프로퍼티나 메서드를 차레대로 검색한다.

## 프로퍼티 정의

- 갱신 가능하도록 할 것인지, 열거 가능하도록 할 것인지
- Object.defineProperty 메서드를 사용하면 프로퍼티의 어트리뷰트를 정의할 수 있다.

## 객체 변경 방지

### 객체 확장금지

- Object.preventExtensions
- 추가 금지를 의미한다.
- 삭제는 가능하다.(delete)
- isExtensible 로 확장이 가능한 객체인지 확인할 수 있다.

### 객체 밀봉

- Object.seal
- 프로퍼티 추가 및 삭제와 프로퍼티 재정의 금지를 의미한다.
- Object.isSealed로 확인한다.

### 객체 동결

- Object.freeze
- 동결된 객체 -> 읽기만 가능하다.
- Object.isFrozen으로 확인 한다.

#### 중첩 객체까지는 영향을 줄 수 없다.

```
  const person = {
    name : "Lee",
    address : { city : "Seoul"}
  }

  console.log(Object.isFrozen(person.address)) // false
```

### isFroze을 재귀적으로 호출해야함

```
function deepFreeze (target) {
  if(targe && typeof target == 'object' && ! Object.isFrozen(target)){
    Object.freeze(target)
    Object.keys(target).forEach(key => deepFreeze(target[key]))
  }
  return target ;
}

const person = {
  name : "Lee",
  address : {city : "Seoul"}
}

deepFreeze(person);
```

### Object 생성자 함수

- new 연산자와 함께 호출

#### Object 생성자 함수를 사용해서 빈 객체를 생성해야 하는 것은 아니다. 또한 특별한 이유가 없다면 그다지 유용해보이지는 않는다.

```
const circle = {
  radius : 5,
  getDiameter () {
    return 2 * this.radius
  }
}

const circle2 = {
  radius : 10,
  getDiameter () {
    return 2 * this.radius
  }
}

console.log(circle.getDiameter()) //10
console.log(circle2.getDiameter()) // 20
```

### 이럴 때 생성자 함수 가능

```
function Circle (radious){
  radious = this.radius
  return this.radius * 2
}

const circle = new Circle(5)
const circle2 = new Circle(10)
```

> 코드 치니까 재밌다.

# this

#### this 키워드는 항상 중요하고 어려우니까 젤 큰 글씨로 함 ㅋㅋㅋ

> this는 객체 자신의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수다. this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 따라 동적으로 결정된다.

## this 예제를 보다보니 신기한게 있다.

```
const circle3 = Circle(15);

console.log(circle3);

console.log(radius); 15
```

#### radius가 전역으로 15를 가리키는게 신기하지 않음??

> new 연산자로 함께 호출하지 않은 Circle은 일반 함수로서 동작하고 this 바인딩은 전역을 가리키게 되기 때문에 전역 this는 (window.this) 15가 된것이다. 간단하게 생각하면 별거 아니다 라고 생각할 수 있지만 최근에 스터디에서도 this와 관련해서 뜨거운 논쟁이 있었기 때문에 당연하고 단순한것이지만 잘 구분해서 알아놔야 할것 같다.

#### 생성자 함수의 역할은 프로퍼티 구조가 동일한 인스턴스를 생성하기 위한 템플릿으로서 동작하여 인스터를 생성하는 것과 생성된 인스턴스를 초기화하는 것이다.

### 바인딩??

> 바인딩이란 식별자와 값을 연결하는 과정을 의미한다. 예를 들어, 변수 선언은 변수 이름과 확보된 메모리 공간의 주소를 바인딩하는 것이다. this 바인딩은 this와 this가 가리킬 객체를 바인딩하는 것이다.

## Node.JS에서 this 전역은?

<img src="./images/스크린샷 2023-09-02 오전 1.06.04.png" alt="nodejs 전역 this는?">

- browser에서 실행하면 window다 (아마 chrome v8 엔진 실행 환경이라..?)

#### 일반 객체는 호출할 수 없지만 함수는 호출할 수 있다는 점이 함수와 일반 객체의 차이점.

호출 가능한 함수는 [[Call]] 이라는 내부 메서드를 가지고 callable이라 하고 생성자 함수로서 호출하면 [[Construct]]라는 내무 메서드를 가지게 된다.

따라서 모든 함수는 [[Call]]이라는 내부 메서드를 가지고 있어서 callable하지만 모든 함수가 [[Construct]]를 갖는 것은 아니다.

> 따라서 함수 객체는 construct를 가질수도 있고 아닐수도 있다는 말이다~

> 화살표함수는 ? construt를 가지지 않는다.

```
const arrow = () => {};

new arrow(); //TypeError : arrow is not a contructor
```
